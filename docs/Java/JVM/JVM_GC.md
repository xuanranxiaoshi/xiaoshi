# JVM 垃圾回收机制

## 一、堆空间的基本结构

Java 的自动内存管理主要是针对对象的内存回收和对象的内存分配，而绝大部分对象都被分配在堆上，因此，Java 自动内存管理最核心的功能就是 **堆** 内存中对象的分配与回收。

Java 堆是垃圾收集器管理的主要区域，因此也被称作 **GC 堆（Garbage Collected Heap）**。

从垃圾回收的角度来说，由于现在收集器基本都采用**分代垃圾收集算法**，所以 Java 堆被划分为了几个不同的区域，这样我们就可以**根据各个区域的特点选择合适的垃圾收集算法**。

在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：

1. **新生代内存(Young Generation)**
2. **老生代(Old Generation)**
3. **永久代(Permanent Generation)** 

其中在 JDK 1.8 及之后用元空间替代永久代，并在本地内存中实现；下图所示的 **Eden** 区、两个 **Survivor** 区 S0 和 S1 都属于新生代，中间一层属于**老年代**，最下面一层属于**永久代**。

![堆结构](./images/hotspot-heap-structure.png)

## 二、堆内存的分配及回收原则

### 2.1 对象的分配原则

- **对象优先在 Eden 区分配**：当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC
- **大对象直接进入老年代**：大对象直接进入老年代的行为是由虚拟机动态决定的，它与具体使用的垃圾回收器和相关参数有关。大对象直接进入老年代是一种优化策略，旨在避免将大对象放入新生代，从而减少新生代的垃圾回收频率和成本。
- **长期存活的对象进入老年代**： 大部分情况，对象都会首先在 Eden 区域分配。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中，并将**对象年龄**设为 1(Eden 区->Survivor 区后对象的初始年龄变为 1)。对象在 Survivor 中每熬过一次 MinorGC, 年龄就增加 1 岁，对象达到晋升老年代的年龄阈值，则会晋升到老年代中。

---

**空间分配担保**： 

* 空间分配担保是为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。
* JDK 6 Update 24 之后的规则为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。

### 2.2 垃圾回收的类型

针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：

**部分收集 (Partial GC)**：

- 新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；

- 老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；

- 混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。

**整堆收集 (Full GC)**：收集整个 Java 堆和方法区

## 三、死亡对象的判断方法

### 3.1 引用计数法

* 无法解决循环依赖问题

### 3.2 可达性分析算法

* 通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链
* 当一个对象没有从 GC Roots 出发的任何引用链相连的话，则证明此对象是不可用的，需要被回收。
* 可以作为 GC Roots 的对象：虚拟机栈中引用的对象、本地方法栈中引用的对象、方法区中类静态属性引用的对象、方法区中常量属性引用的对象、所有被同步锁持有的对象、JNI (Java Native Interface) 引用的对象

### 3.3 引用类型

* **强引用**：默认的引用类型；垃圾回收器将**永远不会回收被引用的对象**，哪怕内存不足时，JVM也会直接抛出OutOfMemoryError，不会去回收。

* **软引用**：在内存足够的时候，软引用对象不会被回收，**只有在内存不足时，系统则会回收软引用对象**，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。这种特性常常被用来实现缓存技术，比如网页缓存，图片缓存等。

* **弱引用**：无论内存是否足够，**只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收**。

* **虚引用**：如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收，永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用。

  ---

  **引用队列：**引用队列可以与软引用、弱引用以及虚引用一起配合使用，当垃圾回收器准备回收一个对象时，如果发现它还有引用，那么就会在回收对象之前，把这个引用加入到与之关联的引用队列中去。程序可以通过判断引用队列中是否已经加入了引用，来判断被引用的对象是否将要被垃圾回收，这样就可以在对象被回收之前采取一些必要的措施。

## 四、垃圾收集算法

### 4.1 标记-清除算法

最基本的清理算法；首先标记出所有不需要回收的对象，标记完成后统一回收掉没有被标记的对象。存在两大缺点：

* 效率问题：标记和清除阶段的效率都不高
* 空间问题：清除后会产生大量不连续的空间碎片

### 4.2 复制算法

在“标记-清除”算法的基础上，将内存分为大小相等的两块，每次只使用其中一块。当一块内存使用完之后就先将还存活的对象复制到另一块内存中去，再将使用的这块内存一次性全部清理。存在的缺点如下：

* 可用内存减小：可用的内存空间减半
* 不适合老年代：存活的对象较多时，复制操作导致性能低下

### 4.3 标记-整理算法

根据老年代特点提出的一种算法，标记过程与标记-清除算法一样，不过后续步骤为将存活对象向内存一端移动，然后清理掉端边界以外的内存区域。整理过程效率也不高，适合老年代这种垃圾回收频率不高的区域。

### 4.4 分代收集算法

根据对象的存活周期，将内存划分为不同的几块区域。Java 堆一般被划分为新生代和老年代，根据各个年代的特点，选择合适的垃圾收集算法。

比如在新生代中，每次收集都会有大量的对象死去，则可以选择“标记-复制”算法，只需要付出少数存活对象的复制代价，就可以完成每次垃圾收集工作；而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。

## 五、垃圾收集器

JDK 默认的垃圾收集器：

- JDK 8：Parallel Scavenge（新生代）+ Parallel Old（老年代）
- JDK 9 ~ JDK20: G1

|            垃圾收集器             |                             特点                             |
| :-------------------------------: | :----------------------------------------------------------: |
|           Serial 收集器           | 单线程；进行垃圾收集工作的时候必须暂停其他所有的工作线程；使用“标记-复制”算法 |
|         Serial Old 收集器         | Serial 收集器的老年代版本，它同样是一个单线程收集器; 使用“标记-整理”算法 |
|           ParNew 收集器           |                 Serial 收集器的多线程版本；                  |
|     Parallel Scavenge 收集器      |     关注点是**吞吐量**（高效率的利用 CPU）；使用复制算法     |
|        Parallel Old 收集器        | Parallel Scavenge 收集器的老年代版本。使用多线程和“标记-整理”算法。 |
| CMS(Concurrent Mark Sweep) 收集器 | **以获取最短回收停顿时间为目标**；**第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。**使用“标记-清除”算法 |
|         G1(Garbage-First)         | **面向服务器**的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. **以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.** |
|            ZGC 收集器             | 采用标记-复制算法，不过 ZGC 对该算法做了重大改进。可以将暂停时间控制在几毫秒以内，出现 Stop The World 的情况会更少，但代价是牺牲了一些吞吐量。 |

### 5.1 CMS 收集器的运行过程

* **初始标记：** 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；

* **并发标记：** 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。

* **重新标记：** 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短

* **并发清除：** 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。

![CMS 收集器](images/cms-garbage-collector.png)

从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：**并发收集、低停顿**。但是它有下面三个明显的缺点：

- **对 CPU 资源敏感；**
- **无法处理浮动垃圾；**
- **它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。**

### 5.2 G1 收集器的运行过程

G1 收集器的运作大致分为以下几个步骤：

- **初始标记**
- **并发标记**
- **最终标记**
- **筛选回收**

![G1 收集器](images/g1-garbage-collector.png)

**G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)** 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率。









## 参考

[1] [JavaGuide-垃圾回收详解](https://javaguide.cn/java/jvm/jvm-garbage-collection.html)