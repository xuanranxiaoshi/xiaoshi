# JVM 基础

## 一、JVM 内存区域划分

Java 虚拟机将其所管理的内存空间划分为不同的区域，而该划分方式在 jdk1.8 存在差异，总体来说 jvm 所管理的内存分为**运行时数据区域**和**本地内存区域**。<br>

jdk 1.7，运行时数据区域包括：线程间共享的**堆**、**方法区**，以及每个线程单独拥有的**虚拟机栈**、**本地方法栈**、**程序计数器**； 本地内存区域包括共享的**直接内存**。<br>

jdk 1.8， 运行时数据区域包括：线程间共享的 **堆**，以及每个线程单独拥有的**虚拟机栈**、**本地方法栈**、**程序计数器**； 本地内存区域包括共享的**直接内存**、**元空间**。<br>

两者的主要区别在于 jdk 1.8 将逻辑区域**方法区**在本地内存中实现为**元空间**，而此前是将其实现为堆结构中的**永久代**。<br>

![jdk 1.7](imges/java-runtime-data-areas-jdk1.7.png)
![jdk 1.8](imges/java-runtime-data-areas-jdk1.8.png)

## 二、JVM 不同内存区域的作用
- **堆**：存放对象实例，几乎所有的对象实例和数组都在这分配内存； 包含**字符串常量池**;从垃圾回收的角度，堆内存常被分为：新生代内存、老生代、永久代（1.8之后为元空间，使用本地内存）
- **方法区**：是 JVM 运行时数据区域的一块逻辑区域（jvm 规范），是各个线程共享的内存区域。方法区会存储已被虚拟机加载的类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据；元空间和永久代为其具体实现；
- **直接内存**：直接内存是一种特殊的内存缓冲区，并不在 Java 堆或方法区中分配的，而是通过 JNI （Java native interface）的方式在本地内存上分配的。
- **程序计数器**：当前线程所执行的字节码的指令指示器
- **虚拟机栈**：实现 java 非 antive 方法调用； 由栈帧组成；**栈帧**包括局部变量表，操作数栈，动态链接、方法返回值
- **本地方法栈**：为 native 方法服务；hotspot 中与虚拟机栈合并；

---
- **运行时常量池**：用于存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）的常量池表(Constant Pool Table)

## 三、JVM 在堆上创建对象的过程
 
1. **类加载检查**：检查 new 指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程
2. **分配内存**: 为新生对象分配内存,分配方式有 **“指针碰撞”** 和 **“空闲列表”** 两种，选择哪种分配方式由 Java **堆是否规整**决定，而 Java 堆是否规整又由所采用的**垃圾收集器**是否带有压缩整理功能决定。
3. **初始化零值**: 将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。
4. **设置对象头**:  虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。
5. **执行 init 方法**: 执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

---
**指针碰撞**

* 适用场合：堆内存规整（即没有内存碎片）的情况下。
* 原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。
* 使用该分配方式的 GC 收集器：Serial, ParNew

**空闲列表**

- 适用场合：堆内存不规整的情况下。
- 原理：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。
- 使用该分配方式的 GC 收集器：CMS

## 四、对象的内存布局

对象主要包含三部分